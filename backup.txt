Forth words that can be done in Forth:
	: - -1 * + ;
	: rot 2 roll ;
	: -rot rot rot ;
	: 2dup over over ;
	: mod 2dup / * - ;
	: 2drop drop drop ;
	: >= 2dup > -rot = or ;
	: <= 2dup < -rot = or ;
	: negate -1 * ;
	: invert negate 1 - ;
	: <> = invert ;

// -----------------------------------------------------------------------------
// TO BE RE-ADDED
// -----------------------------------------------------------------------------

// Functions I _THINK_ I'll need for loading files (later)
cbm_open(2, diskDrive, 2, fileName);
cbm_read(2, dictionary, DICT_SIZE);



// -----------------------------------------------------------------------------
// COMPILER STUFF
// -----------------------------------------------------------------------------

void clearCompiledWord() {
	static char* start;
	static uint16_t i = 0;
	
	// Build the start of the definition ("\n" + the name of the word)
	memset(currentWord, 0, 81);
	currentWord[0] = '\n';
	i = 0; while (ip[i] == ' ') i++;
	while(ip[i] == ' ') i++;
	for (; i<81; i++) {
		redefined[i + 1] = ip[i];
		if (ip[i] == ' ') break;
	}
	
	// Check if the word is already in the dictionary
	start = strstr(dictionary, redefined);
	if (start == NULL) return;
	
	// If it gets here, we ARE redefining a word
	redefining = true;
	
	// Write over the old definition
	start++;
	while(start[0] != '\n') {
		i = 0;
		while(start[i] != '\0') {
			start[i] = start[i + 1];
			i++;
		}
	}
	
	// The code above leaves us with a double \n, which makes the "compiler"
	// word a bit less useful and wasts bytes users could use for their code.
	// So jump thru that hoop one more time (maybe make this an function in the
	// future - but right now... IT WORKS!  YES!!!  Thank you Lord! :)
	i = 0;
	while(start[i] != '\0') {
		start[i] = start[i + 1];
		i++;
	}
}

bool InDictionary() {
	// Build a string: \n + current word + space
	static char wordName[82], * temp;
	static uint16_t i;
	memset(wordName, 0, 82);
	wordName[0] = '\n';
	temp = ip; i = 0;
	while(temp[0] != ' ' && temp[0] != '\n') {
		wordName[i + 1] = temp[0];
		i++; temp++;
	}
	i++;
	wordName[i] = ' ';
	
	// If this combo is not found in the dictionary, do nothing
	temp = strstr(dictionary, wordName);
	if (temp == NULL) return false;
	
	// If it gets here, it IS in the dictionary, so push every word in its
	// definition onto the return stack.  To get there, I need to do like I did
	// in the main loop.  First, move to the end of the definition:
	temp++;
	while(temp[0] != '\n') temp++;	// End of the definition
	temp--;		// so it's not at the closing \n anymore
	
	// Now again, like I did there, work backward till it reaches the word in ip
	while(temp[0] != '\n') {
		while(temp[0] == ' ') temp--;
		while(temp[0] != ' ' && temp[0] != '\n') temp--;
		if (temp[0] == '\n') break;
		temp++;
		rs[rsp] = (uint16_t)temp;
		rsp++;
		temp--;
	}
	return true;
}




// -----------------------------------------------------------------------------
// MAIN
// -----------------------------------------------------------------------------

void main() {
	static uint16_t length;
	
	while(true) {
		// Run it, one word at a time
		while(rsp > 0) {
			
			// If we're compiling, keep compiling unless it's a semicolon
			if (compiling) {
				If it's a semicolon...
					strcat(dictionary, "\n");
					compiling = false;
					status = STATUS_OK;
					if (redefining) {
						redefined[0] = ' ';
						printf("redefined%s\n", redefined);
					}
					redefining = false;
				}
				else {
					length = strlen(dictionary);
					while(ip[0] != ' ') {
						dictionary[length] = ip[0];
						length++;
						ip++;
					}
					dictionary[length] = ' ';
				}
				continue;
			}

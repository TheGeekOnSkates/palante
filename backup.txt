Forth words that can be done in Forth:
	: - -1 * + ;
	: rot 2 roll ;
	: -rot rot rot ;
	: 2dup over over ;
	: mod 2dup / * - ;
	: 2drop drop drop ;
	: >= 2dup > -rot = or ;
	: <= 2dup < -rot = or ;
	: negate -1 * ;
	: invert negate 1 - ;
	: <> = invert ;




// Misc. constants

#define INPUT_SIZE 80
#define STACK_SIZE 256
#define DICT_SIZE 4096


// Status codes

#define STATUS_OK				0		// No error, "ok"
#define STATUS_COMPILED			1		// All words compiled successfully
#define STATUS_STACK_UNDERFLOW	2		// Stack underflow error
#define STATUS_DIV_BY_ZERO		3		// Division by 0 error
#define STATUS_UNKNOWN_WORD		4		// Unknown word error
#define STATUS_RS_UNDERFLOW		5		// Return stack underflow error


// -----------------------------------------------------------------------------
// GLOBAL VARIABLES
// -----------------------------------------------------------------------------

uint8_t status = STATUS_OK,		// System status
	ms[STACK_SIZE], msp;		// Memory stack (for strings)
char input[INPUT_SIZE],			// User input buffer
	redefined[81];				// If redefining a word




// -----------------------------------------------------------------------------
// FORTH WORDS
// -----------------------------------------------------------------------------

void dotQuote() {
	static uint8_t i;
	if (!rsp) { status = STATUS_RS_UNDERFLOW; return; }
	while(rs) {
		next();
		i = 0;
		while(ip[i] != ' ') {
			if (ip[i] == '"') return;
			putchar(ip[i]);
			i++;
		}
		putchar(' ');
	}
}

void sQuote() {
	static uint8_t i;
	if (!rsp) { status = STATUS_RS_UNDERFLOW; return; }
	ds[dsp] = (uint16_t)ms + msp;
	dsp++;
	while(rs) {
		next();
		i = 0;
		while(ip[i] != ' ') {
			if (ip[i] == '"') break;
			ms[msp] = ip[i];
			msp++;
			i++;
		}
		if (ip[i] == '"') break;
		ms[msp] = ' ';
		msp++;
	}
	ds[dsp] = (uint16_t)ms + msp - ds[dsp - 1];
	dsp++;
}

void load() {
	static int8_t result;
	static char fileName[20];
	static uint8_t i, diskDrive;
	if (dsp < 3) { status = STATUS_STACK_UNDERFLOW; return; }
	dsp--;
	diskDrive = ds[dsp];
	dsp--;
	for (i=0; i<ds[dsp]; i++) {
		fileName[i] = PEEK(ds[dsp - 1] + i);
	}
	dsp--;
	fileName[i] = '\0';
	result = cbm_open(2, diskDrive, 2, fileName);
	
	// The first 2 bytes are something internal, probably
	// a file delimiter or the size of the file or something.
	// We'll just skip those.
	result = cbm_read(2, dictionary, 2);
	
	result = cbm_read(2, dictionary, DICT_SIZE);
}



// -----------------------------------------------------------------------------
// TO BE SORTED
// -----------------------------------------------------------------------------

/**
 * At the beginning of the compile process, this deletes any previous definition
 * of the word (kind of like FORGET in some Forths.  Hmmmm...) :D
 */
void clearCompiledWord() {
	static char* start;
	static uint16_t i = 0;
	
	// Build the start of the definition ("\n" + the name of the word)
	memset(redefined, 0, 81);
	redefined[0] = '\n';
	i = 0; while (ip[i] == ' ') i++;
	while(ip[i] == ' ') i++;
	for (; i<81; i++) {
		redefined[i + 1] = ip[i];
		if (ip[i] == ' ') break;
	}
	
	// Check if the word is already in the dictionary
	start = strstr(dictionary, redefined);
	if (start == NULL) return;
	
	// If it gets here, we ARE redefining a word
	redefining = true;
	
	// Write over the old definition
	start++;
	while(start[0] != '\n') {
		i = 0;
		while(start[i] != '\0') {
			start[i] = start[i + 1];
			i++;
		}
	}
	
	// The code above leaves us with a double \n, which makes the "compiler"
	// word a bit less useful and wasts bytes users could use for their code.
	// So jump thru that hoop one more time (maybe make this an function in the
	// future - but right now... IT WORKS!  YES!!!  Thank you Lord! :)
	i = 0;
	while(start[i] != '\0') {
		start[i] = start[i + 1];
		i++;
	}
}

/**
 * Checks if the current word is in the dictionary, and puts its definition on
 * the return stack if it is
 * @returns True if the word is in the dictionary, false if it isn't
 */
bool InDictionary() {
	// Build a string: \n + current word + space
	static char wordName[82], * temp;
	static uint16_t i;
	memset(wordName, 0, 82);
	wordName[0] = '\n';
	temp = ip; i = 0;
	while(temp[0] != ' ' && temp[0] != '\n') {
		wordName[i + 1] = temp[0];
		i++; temp++;
	}
	i++;
	wordName[i] = ' ';
	
	// If this combo is not found in the dictionary, do nothing
	temp = strstr(dictionary, wordName);
	if (temp == NULL) return false;
	
	// If it gets here, it IS in the dictionary, so push every word in its
	// definition onto the return stack.  To get there, I need to do like I did
	// in the main loop.  First, move to the end of the definition:
	temp++;
	while(temp[0] != '\n') temp++;	// End of the definition
	temp--;		// so it's not at the closing \n anymore
	
	// Now again, like I did there, work backward till it reaches the word in ip
	while(temp[0] != '\n') {
		while(temp[0] == ' ') temp--;
		while(temp[0] != ' ' && temp[0] != '\n') temp--;
		if (temp[0] == '\n') break;
		temp++;
		rs[rsp] = (uint16_t)temp;
		rsp++;
		temp--;
	}
	
	return true;
}

void main() {
	static uint16_t length;
	
	while(true) {
		// Parse user input
		accept();
		
		// Run it, one word at a time
		if (!compiling) status = STATUS_OK;
		while(rsp > 0) {
			// If the status is not OK or COMPILED, exit the loop
			if (status > STATUS_COMPILED) {
				dsp = 0;
				rsp = 0;
				break;
			}
			
			// Pop the return stack to the input pointer
			next();
			
			// If we're compiling, keep compiling unless it's a semicolon
			if (compiling) {
				if (isName) clearCompiledWord();
				isName = false;
				if (StringStartsWith(ip, "; ")) {
					strcat(dictionary, "\n");
					compiling = false;
					status = STATUS_OK;
					if (redefining) {
						redefined[0] = ' ';
						printf("redefined%s\n", redefined);
					}
					redefining = false;
				}
				else {
					length = strlen(dictionary);
					while(ip[0] != ' ') {
						dictionary[length] = ip[0];
						length++;
						ip++;
					}
					dictionary[length] = ' ';
				}
				continue;
			}
			
			// This is not a standard Forth word, but a tutorial I followed once
			// (the one I learned this compiler strategy from) had it and I like
			// it, so it works for now (lol).  Maybe I'll replace it with "SEE"
			// later... or maybe I'll just leave it :)
			if (StringStartsWith(ip, "compiler ")) {
				printf("\n%s", dictionary);
				continue;
			}

			// Handle Forth words
			if (StringStartsWith(ip, ": ")) {
				compiling = isName = true;
				continue;
			}

			// If it's not a number, is it in the dictionary?
			if (InDictionary()) continue;
			
			// If it's not in the dictionary, it' an error
			status = STATUS_UNKNOWN_WORD;
			
			// If at any point there's an error, stop running
			if (status > STATUS_COMPILED) {
				dsp = 0;
				rsp = 0;
				break;
			}
		}
	}
}
